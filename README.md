# ðŸ”— Network Synchronization of Lorenz Oscillators

This repository contains **MATLAB** code for simulating and **Python** code for visualizing the synchronization of a network of coupled Lorenz oscillators.
The project demonstrates the application of **spectral graph theory** specifically weighted Laplacian matrices and a novel weight assignment methodâ€”to achieve and analyze network synchronization across **switching topologies**.

---

## ðŸ“– Project Overview

The core of this project is a set of MATLAB scripts that model and simulate a network of 6 chaotic Lorenz oscillators across **three consecutive time intervals** (using graphs **$G1, G2, G3$**).

* The **`SyncCouplingAssign`** function implements a method based on **Negative Imbalance Vectors** and **Cycle Basis Vectors** to assign coupling weights that guarantee synchronization.
* Synchronization error is calculated as the **L2 norm** distance between an oscillator's state and all other oscillators.
* Simulation data (time and synchronization error) is exported to an Excel file, **`synchronization_data.xlsx`**.
* The **Jupyter Notebook** is used to load and visualize this simulation data.

---

## ðŸ“‚ File Descriptions

### MATLAB Scripts

| File Name | Description | Key Mechanism |
| :--- | :--- | :--- |
| **`main.m`** | **Main simulation script.** Defines parameters ($\sigma, \rho, \beta$), sets up the three switching connectivity digraphs ($G1, G2, G3$), assigns weights using `SyncCouplingAssign`, runs the full time-multiplexed simulation, and plots/saves the synchronization error. | Switching topology simulation across $G1 \to G2 \to G3$ |
| **`LorenzOscillator.m`** | Defines the uncoupled dynamics ($f(X)$) of a single Lorenz system (state: $[x; y; z]$). | $\sigma=10$, $\rho=28$, $\beta=8/3$ |
| **`SimulateCoupledSystems.m`** | Integrates the network dynamics using `ode45`. It first builds the **weighted Laplacian matrix ($L$)** from the input graph $G$. | Numerical integration via `ode45` |
| **`CoupledDynamics.m`** | Defines the full coupled network dynamics ($\dot{X}$) required by `ode45`. Implements the diffusive coupling $\left( -P L X^T - P X \right)$. | Applies coupling through Projection Matrix **$P$** and Laplacian **$L$** |
| **`SyncCouplingAssign.m`** | **Core weight assignment function.** Calls both `NegativeImbalanceVector` and `CycleBasisVector` sequentially to determine the synchronizing edge weights based on parameter $a$. | Calls `NegativeImbalanceVector` and `CycleBasisVector` |
| **`NegativeImbalanceVector.m`** | Assigns an initial set of positive edge weights to ensure all but one vertex in each Strongly Connected Component (SCC) has a **negative imbalance** with respect to parameter $a$. | Uses **Shortest Path** algorithm to assign weights |
| **`CycleBasisVector.m`** | Computes a final set of positive edge weights based on the **cycle basis** of the SCCs to ensure all edges are active and weighted appropriately for synchronization. | Uses cycles to ensure **non-zero weights** for edges within SCCs |

### Python Visualization

| File Name | Description | Key Function |
| :--- | :--- | :--- |
| **`synchronization_plot.ipynb`** | A **Jupyter Notebook** for visualizing the simulation results generated by `main.m`. It loads the data from `synchronization_data.xlsx` and generates publication-quality plots of the synchronization error over time. | Loads **`synchronization_data.xlsx`** and plots error trajectories |

---

## ðŸš€ Getting Started

### Prerequisites

* **MATLAB** (R2017b or newer recommended).
* **Python** (with Jupyter Notebook and packages: `pandas`, `matplotlib`, `numpy`) for visualization.

### Usage

1.  **Simulate in MATLAB**
    * Place all MATLAB `.m` files in the same directory.
    * Run `main` in the MATLAB Command Window.
    * This generates the simulation data and the **`synchronization_data.xlsx`** file.

2.  **Visualize in Python**
    * Ensure the **`synchronization_data.xlsx`** file is accessible to your Jupyter Notebook environment.
    * Open and run the cells in **`synchronization_plot.ipynb`** to visualize the results.

---

## ðŸ“Œ Notes on Synchronization Theory

* **Coupling Parameter ($a$):** The value `a` is analytically derived in `main.m` to be sufficient for synchronizing the Lorenz system, relating to the one-sided Lipschitz constant of the uncoupled system.
* **Projection Matrix ($P$):** The coupling is applied only to the $x$-state, as set by `P = diag([1, 0, 0])`.
* **Generalizability:** This weight assignment framework generalizes beyond Lorenz oscillators to any system whose local dynamics satisfy the required QUAD condition, using the corresponding constant as parameter $a$.
